# 그리디 알고리즘

# 16953 -> 2212 -> 13975

# 16953
맨 뒷자리가 0이 아닌 짝수(2,4,6,8) -> 2를 곱해서 만들 수 있음.
맨 뒷자리가 1 -> 그 앞의 수를 만들고 나서 1을 추가해서 만들 수 있음.

안되는 것: 자릿수에 1이 아닌 홀수가 포함되어 있을 때는 불가능하다.

A에서 시작해서 B를 완성하는 방식: 범위가 더 넓다.
B에서 A를 만드는 역방향 방식: 점점 범위를 좁혀나갈 수 있기에 더 효율적.
따라서 후자의 방식을 사용

거꾸로 가는 방식에서는
1. 짝수 상황에서 2로 나눈다
2. 일의 자리가 1인 상황에서는 1을 지운다(즉 10으로 나누고 나머지를 버린다)
이렇게 2가지 방식 중 선택할 수 있다.

그리디한 방식을 사용해서
2로 계속 나누며 A인지 확인,
일의 자리가 1이고 A가 아니면 10으로 나누고 나머지를 버린다.

A보다 값이 작아지면 만들 수 없는 수로 판단 후 종료
위의 과정을 반복하도록 구현해본다.

# 2212
하나의 기지국이 여러 범위를 포함해야 하는 경우 -> 최대 세울 수 있는 집중국 개수를 넘어갈 때.

따라서 일단 수신가능영역을 최소로 하는 집중국 위치를 구한다.

### 큰 문제 해결 방식
최대 집중국 개수가 될 때까지 반복하면 수신가능영역의 최솟값을 구할 수 있다.

### 구현
1. 센서 위치 받고 -> 오름차순 정렬
2. 센서 위치마다 기지국을 세울 수 있음 -> 0을 리턴 (수신 가능 영역은 전부 0)
3. 센서 간의 간격을 계산하여 내림차순으로 sort, 순서대로 stack에 넣음 (센서 간 간격이 가장 작은 것이 top에 존재하도록)
4. 간격을 정답에 더해가며 기지국의 수신 가능 영역을 넓히는 과정을 반복, 기지국 개수가 최대 기지국 개수와 동일해지면 종료

#### 예시
1 3 6 6 7 9
간격: 2 3 0 1 2

1. 0을 합친다
2. 간격 1을 합친다 -> 정답에 1을 더한다 (합쳐서 수신 가능 영역이 1이 됨)
3. 간격 2를 합친다 -> 정답에 2를 더한다
4. 간격 2를 합친다 -> 정답에 2를 더한다.
남은 간격: 3 => 이 간격을 두고 2개의 집중국이 있는 상태.
따라서 집중국 개수가 2개가 됐으므로 종료,
정답은 5

# 13975
계속해서 정렬이 필요함 -> `priority_queue` 자료구조 사용
1. 작은 수끼리 합치는 것을 반복.
2. queue에 숫자가 한 개만 남을 때까지

#### 범위
파일 개수의 최댓값은 1,000,000이고 
파일 크기의 최댓값은 10,000이다.
따라서 최악의 경우(파일 크기가 전부 10,000인 경우) 누적합이 10,000 * 1,000,000이 될 수 있고 이 수는 int 범위(2.1 * 10^9)를 넘어섬.

따라서 `long long` 형을 사용해야 알맞다.