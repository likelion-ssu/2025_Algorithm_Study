# 완전탐색과 백트래킹 학습

## 참고 링크 : https://blog.naver.com/jhc9639/222300377004

## 핵심 정리

### brute force(완전 탐색)

기본은 for 혹은 while을 이용한 완전 탐색이다.
재귀함수를 활용한 완전 탐색도 가능하다. 하지만 반복문이 가능하면 cost가 큰 함수호출보다는 가볍게 반복문을 사용하는 게 좋다.
너무 복잡하거나, 매개변수만 잘 수정해서 넘기면 해결될 것 같을 때 재귀함수를 사용하면 된다.

### back tracking(백트래킹)

백트래킹 정의: 해를 찾는 도중 해가 아니어서 막히면, 되돌아가 다시 해를 찾아가는 기법.
완전탐색 & 가지치기이고 완전탐색에 "인간미"를 섞었다고 표현한다.
불필요한 경우의수 탐색을 줄이기 위해 필요없는 경우의 수는 가지를 치지 않으면 된다.

### 원복 (원상 복구)

독립적인 경우의 수들끼리 서로 영향을 미치지 않게 하기 위해 원상 복구가 필요하다. 보통은 방문 배열인 visited를 통해 색칠하고 다시 지운다(원복)을 통해 가능하다.

# 필수 문제 풀이

## 16439 치킨치킨치킨

날짜: 2025.07.10

### 문제 이해

사람수: N명
치킨 종류: M가지
조건)

- 회원마다 치킨 선호도가 있다.
- 회원의 만족도는 시킨 치킨 중 선호도가 가장 큰 값으로 결정
  목표)
- 회원들의 만족도의 "합"이 최대가 되도록 최대 3가지 종류의 치킨을 주문

### 풀이와 생각

가장 먼저 떠오른 것은 단순 반복문 사용하여 모든 경우 비교하기. 하지만 조금이라도 효율적으로 구현할 수 있을까?

#### 생각 1 : 개선 방법

위의 링크로 간단히 공부하며 "백트래킹"에 대해서 학습했고, max 값이 존재한다면 early return을 하도록 구현할 수 있을 것이라 생각했다.
이 문제에서는 N은 최대 30, M은 최대 30이라 시간 복잡도가 중대하게 줄어들진 않지만, 데이터의 양이 커졌을 때에는 좋은 방법이 될 수 있을 것 같다.

#### 생각 2 : 문제 해석

"최대 세 가지 종류의 치킨" -> 그러면 1가지 혹은 2가지 치킨을 시켜서 최대 만족도를 얻을 수 있을까?
-> 보통 좀 더 꼰 문제에선 시간이라는 변수를 하나 더 두어 한번 더 생각하게 만들 수 있지만 이 문제에서는 "선호도"라는 변수만 보면 된다. 따라서 무조건 3가지 종류의 치킨을 시키게 될 것이다. (이때 M이 3보다 크거나 같다는 조건도 한번 확인하면 좋다. 만약 1보다 크거나 같았다면 구현이 달라진다.)

## 14620 꽃길

날짜: 2025.07.11

### 문제 이해

꽃밭의 넓이: N\*N
꽃밭의 지점(각 좌표): (1,1)~(N,N)의 지점 존재

동작: 1년 후에 꽃이 핀다. (n,n) 지점에 씨앗을 심었다면 (n+1,n), (n-1,n), (n, n+1), (n-1)에 꽃술이 존재하게 된다.

제약: 어떤 씨앗의 꽃이 핀 뒤 다른 꽃잎(꽃술)과 닿게 되면 두 꽃 모두 <u>죽어버린다</u>

### 목표

지점마다 화단 대여 가격이 다르기 때문에

1. 서로 다른 세 씨앗의 꽃이 모두 피게 하면서
2. 가장 싼 가격에 화단을 대여하고 싶다.

### 풀이와 생각

1. 앞서 풀었던 16439 문제와 형식이 비슷하다고 느꼈다. 어떤 제약 속에서 가장 ~한 점(최소/최대 등)을 찾는 문제다.

2. 이건 반복문으로 완전탐색 쓰면 너무 비효율적이다. 최대 100개의 화단에 위치에 대해 씨앗의 위치 3개를 정해야 한다. 따라서 앞서 공부했던 백트래킹을 사용해보고자 한다.
   또한 같은 작업을 3번 반복하기에 반복문을 사용하면 너무 길어질 것 같아 재귀를 사용하는 게 좋아보였다. 여기에다가, 반복문 내부에 모든 로직을 넣으려다보니 너무 복잡하고 가독성이 좋지 않아 기능 별로 함수를 나눠 주었다.

3. 예외처리
   화단의 맨 끝에는 씨앗을 심을 수 없을 거다.

## 16637 괄호 추가하기

날짜: 2025.07.13

### 문제 이해

수식의 길이: N
수식의 구성: 0~9 정수와 연산자(+, -, x)

#### 조건

1. 연산자 우선순위는 모두 동일하므로 왼쪽에서부터 순차 계산
2. 괄호 추가가 가능하며, 괄호식의 우선순위는 높아진다. 단, 괄호 안에는 연산자가 오직 하나 들어있다. 또한, 중첩된 괄호는 사용 불가하다.

#### 목표

수식이 주어지면, 괄호를 추가하여 만들 수 있는 결과의 최댓값을 구한다. (괄호를 추가하지 않아도 된다.)

### 풀이와 생각

삽입되는 괄호의 위치: 숫자의 바로 앞, 끝나는 위치는 항상 그 다음 숫자의 바로 뒤로 고정된다.
따라서 괄호 위치의 경우의 수는 (숫자의 개수-1)와 동일하지만, 모든 경우가 함께 존재할 수는 없음(예를 들어 8+1*3에서는 두 가지 경우의 수만 존재 : (8+1)*3 혹은 8+(1\*3))

#### 처음 접근

처음 접근 -> 가능한 괄호 위치마다 그 괄호가 존재하는지 존재 안 하는지를 표시해두고 한번에 계산
=> 계산식이 너무 복잡해지고 종료 조건이 너무 복잡해졌음.

#### 두번째 접근

dfs 과정에서 계산을 해나가는 것으로 변경.

괄호가 가능한 위치에서 경우의 수 2가지

- 괄호가 있는 경우: 괄호 계산하고, 다다음 연산자로 jump
- 괄호가 없는 경우: 일반 계산하고, 다음 연산자로 이동

#### 헷갈렸던 부분

(1) 인덱스 기준을 어디에 둬야 처음/마지막 처리가 쉬워질까?

- 처음 숫자? -> 0 -> 0번째 인덱스
- 처리해야 하는 연산자? -> 1번째 인덱스

(2) 현재 위치에 괄호를 묶어야 할까, 다음 위치에 괄호를 묶어야 할까?
다음 위치. 이유: 현재 위치부터 괄호를 묶는 것은 괄호가 없을 때와 같은 계산 방식. (이미 왼쪽에서 오른쪽으로 연산하는 방식이기 때문에)
