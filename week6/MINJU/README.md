# 개념
Map, Set, Priority Queue(우선순위 큐)

## 1. map
https://velog.io/@ymj7250/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-map

각 노드가 key와 value 쌍으로 이루어진 트리로, 중복을 허용하지 않는다.
중복을 허용하지 않으므로 key값이 겹치는 값이 들어왔을 때에는 갱신되는 것이 아니라 아예 삽입되지 않는다.
key 값으로 value에 접근하고자 할 때 사용된다.

`정렬`
- 내부에서 key 값을 기준으로 자동 정렬된다. 오름차순이 기본이다.
- 내림차순 정렬을 원한다면 `map<string, int, greater<string>> mp`과 같이 선언하면 된다.

`검색`: find()
- iterator을 사용하며, 데이터를 끝까지 찾지 못했을 경우 iterator은 `map.end()`를 반환한다. map의 끝과 비교하여 발견 여부를 확인하면 된다.

`삽입`: insert() 혹은 key값을 사용한 삽입

`접근`
- key값을 가지고 배열을 사용하듯 value에 접근한다. 즉, index 대신 key를 사용하는 느낌이다.

### 내부 구현
- map
내부적으로 Red-Black Tree로 구현된다. 따라서 탐색, 삭제 전부 O(log N) 내로 실행된다.

- unordered_map
정렬 없이 저장되지만, 저장 순서대로 데이터가 삽입되는 것은 아니다.
내부적으로는 해시테이블로 구현된다.

## 2. Set
### 1. set
중복을 비허용하며, 기본적으로 오름차순 정렬된다.
집합의 특성상, 구분하지 않는다.

### 2. multi set
중복이 불가한 일반 set과는 달리 key값이 중복될 수 있다.
기본 오름차순 자동 정렬된다.
내부적으로 이진 검색 트리를 사용하여 접근/검색/삽입/삭제의 시간복잡도는 O(log N)이다.

## 3. Priority queue(우선순위 큐)
내부적으로는 Heap 자료구조를 사용하며, 모든 원소 중 가장 큰 값이 Top을 유지하도록 설계되어 있다. 최대/최소만 그때그때 필요한 경우 사용하면 좋은 자료구조이다.

우선순위 큐를 사용하다보면, 정렬 기준을 직접 만들어야 하는 경우가 발생한다. 이때, struct를 직접 정의하여 선언시 인자로 넘겨줘야 한다.

```
// pair의 second 값을 기준으로 정렬하는 예시
struct cmp{ bool operator()(pair<int,char> &a, pair<int,char> &b) {
    return a.second > b.second; // second가 크면 true => 더 크다 => 더 밑에 (heap의 구조 생각하기)
}};
```

# 문제 풀이
14425 -> 21939 -> 2696

### 14425
간단하게 set 자료구조를 사용하면 되는 문제.

### 21939 (문제 추천 시스템)
front와 back 둘 다 접근 가능하고, 난이도(내림차순)와 문제 번호(내림차순)으로 정렬하면 된다.

#### 자료구조 선택
- priority_queue를 사용할 수 없다 (앞과 뒤 둘 다 접근 불가)
=> set을 사용하고, 정렬기준을 커스텀한다.

#### 구현
set에서 특정 원소를 삭제하려면 현재 구현으로는 2가지 값(문제 번호, 난이도) 둘 다 필요. 하지만 문제의 solved 명령어의 인자로 주어지는 것은 문제 번호뿐임.
따라서 문제 번호에 따른 난이도를 저장하는 unordered_map을 따로 두어 삭제할 때 사용함. 정석적으로는 특정 문제가 solved 상태로 변하면 map에서도 삭제해야겠지만 여기서는 중복을 비허용하기 떄문에 넘어갔음.

### 2696
정렬 기준을 계속 유지하면서 가운데 값을 접근해야 한다.

풀이 방식: 작은 절반, 큰 절반을 각각의 자료구조로 유지하고, 작은 절반의 최댓값과 큰 절반의 최솟값 중 하나가 중앙값이 된다.

개선할 만한 점: 삭제가 필요 없다면, 2개의 힙(priority_queue)를 사용하는 게 더 성능적으로 나을 수 있음.
#### 삭제의 관점에서 자료구조 바라보기
- priority_queue(heap 기반): top 원소만 관리하기 때문에 중간에 있는 임의의 값은 직접 지울 수 없음, 지우려면 계속해서 pop하고 다시 넣어야 하는 비효율적인 방식을 거쳐야 함.
- multi set(RB 트리 기반): 임의의 원소를 직접 탐색하여 바로 삭제 가능 (`find` 함수 사용 후, `erase` 함수 사용)