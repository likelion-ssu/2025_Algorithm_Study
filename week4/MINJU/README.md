# 그래프 탐색

### 그래프
`정점`: 노드
`간선`: 정점을 잇는 선

`indegree`: 특정 정점에 들어오는 간선
`outdegree`: 특정 정점으로부터 나가는 간선

`가중치`: 정점과 정점 사이에 드는 비용

> 정점과 간선들로 이루어진 집합을 그래프라고 한다.

### 트리
> 자식노드와 부모노드로 이루어진 계층적인 구조를 가지며, 무방향 그래프의 일종이자 사이클이 없는 자료구조

- 항상 V - 1 = E (V = vertex, E= edge) 라는 특징이 있다.

### 그래프 구현과 탐색
#### 1. 인접행렬
정점과 간선의 관계를, 연결 여부에 따라 boolean으로 나타낸 행렬

#### 2. 인접리스트
그래프에서 정점과 간선의 관계를 나타내는 연결리스트
-> `vector`로 구현하는 것이 편하다.

#### 언제 어떤 자료구조를 쓰는 것이 유리할까?
인접행렬은 `O(V^2)`, 인접리스트는 `O(V+E)`의 시간복잡도와 공간복잡도를 가진다.
따라서 그래프가 희소할 때에는 인접리스트를, 그래프가 조밀할 때에는 인접행렬이 좋다.

# 문제 1. 2667 : 단지번호붙이기
DFS로 풀이했습니다!
모든 위치를 확인, 1인 곳부터 시작하여 주변의 모든 1인 곳을 0으로 만드는 과정을 거침. 
더이상 주변에 1인 곳이 없다면 돌아가서 다시 시작점을 찾음.

정답을 저장하기 위해 ans 벡터와 전역변수 cnt를 사용했습니다.

# 문제 2. 7576
BFS 기반 풀이.
이유: 복수의 익은 토마토가 영향을 미치는 토마토가 존재할 수 있음. 그것들에 대해서 가장 먼저 닿는(최소 시간) 토마토를 구하기 위해서는 BFS를 사용하여 "하루씩" 접근해야 함.

#### 개인적으로 기억할 거
빠르게 pair 값 할당하기
`auto [qX,qY] = q.front();`

# 문제 3. 14502
1. 벽을 어디에 세울지 결정하는 과정
-> 모든 가능한 조합을 탐색해야 한다. 
`브루트포스`

2. 벽을 전부 세우고 나서 안전영역을 구하는 과정
-> 바이러스의 근원지부터 시작해서 `bfs`를 사용해서 바이러스가 닿는 곳까지 전부 반영한다.

3. 여러 번 배열 구성을 바꾸고 카운팅 해야 됨
-> 배열을 copy한 `tmpArr`를 사용한다.