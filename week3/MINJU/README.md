# DP (동적 프로그래밍)

## 참고 링크 : https://blog.naver.com/jhc9639/222349317111

## 핵심 정리
DP에서 중요한 것은 `점화식`이다. 
어떠한 idx에서의 모든 경우의 수를 생각하고, 그렇게 완전탐색하는 구조를 만들면 된다. 즉, `완전 탐색+메모이제이션`이라고 생각하는 것이다.

### 메모이제이션이란?
어떤 상태값을 자료구조에 저장하는 것이다. 이미 계산한 값을 저장하여 두 번 이상 벌어지는 로직에 대해 그 값을 쓰느 것이다.

### DP를 사용하기 위한 조건
1. 참조투명성을 가져야 하며 입력을 제외한 외적 요소에 결과값이 영향을 미치지 않아야 한다. (웬만하면 1번은 지켜서 문제가 제시된다.)
2. Overlapping Subproblem: 겹치는 부분 문제가 존재해야 한다.
 예시: 피보나치 수열
3. Optimal Substructure: 최적 부분 구조를 가지고 있어야 한다.

### DP로 풀기 위한 흐름
1. 이거 완전 탐색인데?
2. 경우의 수가 너무 큰데?
3. 메모이제이션이 가능한가?

# 필수 문제 풀이

## 2839
처음에는 그리디하게 접근,
이후 DP를 활용하여 접근함.

5kg 짜리 설탕봉지를 우선적으로 사용해야 한다는 것에 초점을 맞춘다.

# 필수 문제 풀이

## 11660
dp로 값의 합을 저장해둔다.
값을 구할 때에는 중복값을 뺴준다는 개념이 중요하게 사용된다.

# 필수 문제 풀이

## 2294
2839의 dp 풀이를 참고하여 비슷한 형식으로 전개했다.
dp값을 동전의 value를 기준으로, 최솟값으로 채워준 뒤 k에 대한 dp값을 출력해주면 된다!

top down, bottom up
재귀? 배낭/ 플로이드-워샬 문제

